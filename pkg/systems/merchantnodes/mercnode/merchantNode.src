use uo;
use os;

include ":gumps:gumps";
include "include/client";
include "include/gumpUtil";
include "include/mrcSpawn";

var pid, proc, item, restock, respawn, apply, cancel, page := 0, chk := 0, sy := 60, type;

program MerchantNodeManager(who, itm)
  detach();
  item := itm;
  pid  := GetObjProperty(item, "#Pid");
  proc := GetProcess(pid);
  if(!proc)
    SendSysMessage(who, "That merchant node is not responding");
    return;
  endif
  var m_gump := GFCreateGump(0, 0);
  GFPage( m_gump, page );
  page := page + 1;
  GFPage( m_gump, page );
  GFResizePic( m_gump, 0, 0, 5120, 540, 400 );
  GFResizePic( m_gump, 10, 10, 5054, 520, 350 );
  var template := GetObjProperty(item, "Template");
  if(!template)
    template := 1;
    SetObjProperty(item, "Template", 1);
  endif
  if(template == 1)
    GFTextLine( m_gump, 232, 17, 0, "Merchant Node Interface" );
    GFTextLine( m_gump, 230, 15, COLOR_YELLOW, "Merchant Node Interface" );
  else
    GFTextLine( m_gump, 232, 17, 0, "Banker Node Interface" );
    GFTextLine( m_gump, 230, 15, COLOR_YELLOW, "Banker Node Interface" );
  endif
  type := GetObjProperty(item, "Type");
  if(!type)
    type := array;
    SetObjProperty(item, "Type", type);
  endif
  var amt := len(type);
  GFTextLine( m_gump, 20, 40, COLOR_BLUE, "Type" );
  GFTextLine( m_gump, 150, 40, COLOR_BLUE, "X" );
  GFTextLine( m_gump, 210, 40, COLOR_BLUE, "Y" );
  GFTextLine( m_gump, 270, 40, COLOR_BLUE, "Z" );
  GFTextLine( m_gump, 308, 40, COLOR_BLUE, "Enabled" );
  GFTextLine( m_gump, 360, 40, COLOR_BLUE, "Delete" );
  GFTextLine( m_gump, 420, 40, COLOR_BLUE, "Rebuild Stock" );
  FillInPageData(m_gump);
  if(len(type) < 10)
    GFTextLine( m_gump, 40, sy, COLOR_YELLOW, "Create a new merchant here?   (negates all other choices )");
    GFAddButton( m_gump, 20, sy, 210, 211, GF_CLOSE_BTN, 0 );
  endif
  GFTextLine( m_gump, 20, 20, COLOR_GREEN, "Current:" );
  var npclist := GetObjProperty(item, "NpcList");
  var current := 0;
  var holder := array;
  foreach thing in npclist
    if(SystemFindObjectBySerial(Cint(thing)))
      current := current + 1;
      holder.append(thing);
    endif
  endforeach
  SetObjProperty(item, "NpcList", holder);
  if(current == amt)
    GFTextLine( m_gump, 90, 20, COLOR_BLUE, current+"/"+amt );
  elseif(current == 0)
    GFTextLine( m_gump, 90, 20, COLOR_RED, current+"/"+amt );
  else
    GFTextLine( m_gump, 90, 20, COLOR_YELLOW, current+"/"+amt );
  endif
  apply   := GFAddButton( m_gump, 20, 370, G_YELLOW_OVAL_APPLY_0, G_YELLOW_OVAL_APPLY_1, GF_CLOSE_BTN, 0 );
  cancel  := GFAddButton( m_gump, 100, 370, G_RED_OVAL_CANCEL_0, G_RED_OVAL_CANCEL_1, GF_CLOSE_BTN, 0 );
  GetStatus(item, m_gump);
  var retkey  := GFSendGump( who, m_gump );
  if((retkey[cancel.keyid]) || (retkey[0] == 1))
    SendSysMessage(who, "Cancelled", 3, 40);
  elseif(retkey[apply.keyid])
    ResetMerchantNode(who, retkey);
  else
    var ret := retkey[0];
    if(ret < 500)
      ret := Cint((ret - 35) / 25);
      var holder := array;
      foreach thing in type
        if(thing != type[ret])
          holder.append(thing);
        endif
      endforeach
      type := holder;
      SetObjProperty(item, "Type", type);
      holder := array;
      var tmparray := array;
      var newtmp := RequestInput(who, item, "What template would you like to spawn?");
      if(!newtmp)
        SendSysMessage(who, "Cancelled.", 3, 40);
        return;
      else
        tmparray.append(newtmp);
      endif
      SendSysMessage(who, "Target the location where you would like the npc to appear");
      var trg := TargetCoordinates(who);
      if(!trg)
        SendSysMessage(who, "Cancelled.", 3, 40);
        return;
      elseif(trg.realm != itm.realm)
		SendSysMessage(who, "The merchant must be placed in the same facet (realm) as the node.", color := 33);
		SendSysMessage(who, "Canceled.", color := 33);
		return 0;
	  else
        tmparray.append(array(trg.x, trg.y, trg.z));
      endif
      if(template == 1)
        var merctype := FindMerchantType(newtmp);
        if(!merctype)
          SendSysMessage(who, "That is an invalid template", 3, 40);
          return;
        endif
        create_node_merc(merctype, merctype + " " + trg.x + " " + trg.y + " " + trg.z);
      endif
      tmparray.append(1);
      holder.append(tmparray);
      foreach thing in type
        holder.append(thing);
      endforeach
      SetObjProperty(item, "Type", holder);
    endif
  endif
endprogram

function FillInPageData(m_gump)
  var i := 1;
  foreach current in type
    var template := current[1];
    var x        := current[2][1];
    var y        := current[2][2];
    var z        := current[2][3];
    var status   := current[3];
    var color    := COLOR_GREEN;
    if(!status)
      color := COLOR_RED;
    endif
    GFTextLine( m_gump, 20, sy, color, template );
    GFTextLine( m_gump, 150, sy, color, x );
    GFTextLine( m_gump, 210, sy, color, y );
    GFTextLine( m_gump, 270, sy, color, z );
//    GFCheckBox(320, sy, 208, 209, 0, 5000+i);
//    GFCheckBox(370, sy, 208, 209, 0, 6000+i);
//    GFCheckBox(460, sy, 208, 209, 0, 7000+i);
  if(status)
    GFCheckBox(320, sy, 211, 210, 0, 5000+i);
  else
    GFCheckBox(320, sy, 210, 211, 0, 5000+i);
  endif
    GFCheckBox(370, sy, 210, 211, 0, 6000+i);
    GFCheckBox(460, sy, 210, 211, 0, 7000+i);
    sy := sy + 25;
    i := i + 1;
  endforeach
endfunction

function GetStatus(item, m_gump)
  var status := GetObjProperty(item, "Status");
  var color, txt;
    case(status)
      "on":      color := COLOR_GREEN; txt := "Merchant Node Enabled";
                 GFSetRadioGroup( m_gump, 1 );
                 GFRadioButton( m_gump, 20, 308, 208, 209, 1, 200 );
                 GFRadioButton( m_gump, 20, 330, 208, 209, 0, 201 );
      "off":     color := COLOR_RED; txt := "Merchant Node Disabled";
                 GFSetRadioGroup( m_gump, 1 );
                 GFRadioButton( m_gump, 20, 308, 208, 209, 0, 200 );
                 GFRadioButton( m_gump, 20, 330, 208, 209, 1, 201 );
      default:   color := COLOR_GREEN; txt := "Merchant Node Enabled";
                 SetObjProperty(item, "Status", "on");
                 GFSetRadioGroup( m_gump, 1 );
                 GFRadioButton( m_gump, 20, 308, 208, 209, 1, 200 );
                 GFRadioButton( m_gump, 20, 330, 208, 209, 0, 201 );
    endcase
  var cs := GetObjProperty(item, "#wait");
  if(cs == 1)
    color := COLOR_YELLOW;
    txt := "Merchant Node Is Waiting To Initialize";
  elseif(cs == 2)
    color := COLOR_YELLOW;
    txt := "Merchant Nodes Are Disabled Globally";
  elseif(status != "off")
    restock := GFCheckBox(340, 308, 210, 211, 0, 400);
    respawn := GFCheckBox(340, 330, 210, 211, 0, 300);
    GFTextLine( m_gump, 370, 308, COLOR_GREEN, "Restock Merchants" );
    GFTextLine( m_gump, 370, 330, COLOR_GREEN, "Respawn Merchants" );
  endif
  GFTextMid(m_gump, 150, 370, 300, color, txt);
  GFTextLine( m_gump, 50, 308, COLOR_GREEN, "Enable Node" );
  GFTextLine( m_gump, 50, 330, COLOR_GREEN, "Disable Node" );
endfunction

function ResetMerchantNode(who, ret)
  var rsp := 0;
  var newarray := type;
  foreach thing in (ret.keys)
    if((thing >= 5000) && (thing <= 5010))
      Broadcast(CStr(thing));
      var num := thing - 5000;
      var tmpdata := type[num];
      if(tmpdata[3] == 1)
        tmpdata[3] := 0;
      else
        tmpdata[3] := 1;
      endif
      foreach thing in newarray
        if(thing == type[num])
          thing := tmpdata;
          break;
        endif
      endforeach
      rsp := 1;
    elseif((thing >= 6000) && (thing <= 6010))
      var num := thing - 6000;
      var holder := array;
      var tnum := type[num];
      foreach entry in newarray
        if(entry != tnum)
          holder.append(entry);
        endif
      endforeach
      newarray := holder;
      var anchor := tnum[2];
      if(GetObjProperty(item, "Template") == 1)
        Destroy_Node_Merc(FindMerchantType(tnum[1]) + " " + anchor[1] + " " + anchor[2] + " " + anchor[3]);
      endif
      rsp := 1;
    endif
  endforeach
  if(ret[restock.keyid])
    var ev := struct;
    ev.+type := "Restock";
    proc.SendEvent(ev);
  endif
  if((ret[200]) && (GetObjProperty(item, "Status") == "off"))
    rsp := 1;
    SetObjProperty(item, "Status", "on");
  elseif(ret[201])
    SetObjProperty(item, "Status", "off");
    rsp := 1;
  endif
  if((ret[respawn.keyid]) || (rsp == 1))
    if(ret[200])
      SendRespawnEvent();
    else
      SendDespawnEvent();
    endif
  endif
  SetObjProperty(item, "Type", newarray);
  SendSysMessage(who, "Finished updating node");
endfunction

function SendRespawnEvent()
  var ev := struct;
  ev.+type := "Respawn";
  proc.SendEvent(ev);
endfunction

function SendDespawnEvent()
  var ev := struct;
  ev.+type := "Despawn";
  proc.SendEvent(ev);
endfunction